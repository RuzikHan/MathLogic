#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <algorithm>

using namespace std;

string axioms[10] = {"(->,A,(->,B,A))", "(->,(->,A,B),(->,(->,A,(->,B,C)),(->,A,C)))", "(->,A,(->,B,(&,A,B)))",
                     "(->,(&,A,B),A)", "(->,(&,A,B),B)", "(->,A,(|,A,B))", "(->,B,(|,A,B))",
                     "(->,(->,A,C),(->,(->,B,C),(->,(|,A,B),C)))", "(->,(->,A,B),(->,(->,A,(!B)),(!A)))",
                     "(->,(!(!A)),A)"};

map<char, int> variables;
map<int, char> invert_variables;
map<string, int> assumptions;
vector<string> expressionAssumptions;

struct node {
    string value;
    node *left;
    node *right;
};

vector<node *> axioms_trees(10), lines_trees;
vector<node *> assumptions_trees;

string final_line;

void find_variable(string s) {
    int count = 0;
    for (int i = 0; i < s.length(); i++) {
        auto checkcode = int(s[i]);
        if (checkcode >= 65 && checkcode <= 90) {
            if (variables.count(s[i]) == 0) {
                variables[s[i]] = variables.size();
                invert_variables[count] = s[i];
                count++;
            }
        }
    }
}

string expressionParser(string);

string negationParser(string s) {
    if (s.length() == 0) return "";
    if (s[0] == '(')
        return expressionParser(s.substr(1, s.length() - 2));
    if (s[0] == '!') return "(!" + negationParser(s.substr(1)) + ")"; else return s;
}

string conjunctionParser(string s) {
    int brackets_count = 0;
    if (s.length() == 0) return "";
    for (int i = s.length() - 1; i >= 0; i--)
        if (s[i] == '(') brackets_count++;
        else if (s[i] == ')') brackets_count--;
        else if (brackets_count == 0 && s[i] == '&') {
            return "(&," + conjunctionParser(s.substr(0, i)) + "," + negationParser(s.substr(i + 1)) + ")";
        }
    return negationParser(s);
}

string disjunctionParser(string s) {
    int brackets_count = 0;
    if (s.length() == 0) return "";
    for (int i = s.length() - 1; i >= 0; i--)
        if (s[i] == '(') brackets_count++;
        else if (s[i] == ')') brackets_count--;
        else if (brackets_count == 0 && s[i] == '|')
            return "(|," + disjunctionParser(s.substr(0, i)) + "," + conjunctionParser(s.substr(i + 1)) + ")";
    return conjunctionParser(s);
}

string expressionParser(string s) {
    int brackets_count = 0;
    if (s.length() == 0) return "";
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '(') brackets_count++;
        else if (s[i] == ')') brackets_count--;
        else if (brackets_count == 0 && s[i] == '-' && i < s.length() - 1 && s[i + 1] == '>')
            return "(->," + disjunctionParser(s.substr(0, i)) + "," + expressionParser(s.substr(i + 2)) + ")";
    }
    return disjunctionParser(s);
}

void add(string s, node *tree) {
    if (s[0] == '(') {
        s.erase(0, 1);
        s.erase(s.length() - 1, 1);
    }
    int start = 0;
    int brackets_count = 0;
    string left_s = "", right_s = "", val = "";
    bool part = false;
    if (s[0] == '-') {
        start = 3;
        val = "->";
    } else {
        start = 2;
        val = s[0];
    }
    for (int i = start; i < s.length(); i++) {
        if (s[i] == '(') brackets_count++;
        else if (s[i] == ')') brackets_count--;
        if (brackets_count == 0 && s[i] == ',') part = true;
        else if (!part) left_s += s[i]; else right_s += s[i];
    }
    tree->left = new node;
    tree->right = new node;
    if (val == "&" || val == "|" || val == "->") {
        tree->value = val;
        add(left_s, tree->left);
        add(right_s, tree->right);
    } else if (val == "!") {
        tree->value = val;
        add(s.substr(1, s.length() - 1), tree->left);
        tree->right = nullptr;
    } else {
        tree->value = val;
        tree->left = nullptr;
        tree->right = nullptr;
    }
}

void create_axioms_tree() {
    for (int i = 0; i < 10; i++) {
        node *axioma = new node;
        add(axioms[i], axioma);
        axioms_trees[i] = axioma;
    }
}

node *final_tree;

int get_num(string left, int p1, int p2, int p3, int p4, int p5) {
    int left_num = 0;
    if (left == "0") {
        left_num = 0;
    } else if (left == "1") {
        left_num = 1;
    } else {
        switch (variables[left[0]]) {
            case 1:
                left_num = p1;
                break;
            case 2:
                left_num = p2;
                break;
            case 3:
                left_num = p3;
                break;
            case 4:
                left_num = p4;
                break;
            case 5:
                left_num = p5;
                break;
        }
    }
    return left_num;
}

bool compare_trees(node *tree1, node *tree2) {
    if (tree1 == nullptr && tree2 == nullptr) return true;
    if ((tree1 == nullptr && tree2 != nullptr) || (tree1 != nullptr && tree2 == nullptr)) return false;
    if (tree1->value == tree2->value)
        return compare_trees(tree1->left, tree2->left) & compare_trees(tree1->right, tree2->right);
    else return false;
}

bool if_mask_check;

void check_tree(node *tree, int p1, int p2, int p3, int p4, int p5) {
    if (!if_mask_check) {
        for (int i = 0; i < assumptions_trees.size(); i++) {
            if (compare_trees(tree, assumptions_trees[i])) {
                tree->value = "1";
                return;
            }
        }
    }
    if (tree->left != nullptr) check_tree(tree->left, p1, p2, p3, p4, p5);
    if (tree->right != nullptr) check_tree(tree->right, p1, p2, p3, p4, p5);
    if (tree->value == "->" || tree->value == "&" || tree->value == "|") {
        int left_num = get_num(tree->left->value, p1, p2, p3, p4, p5);
        int right_num = get_num(tree->right->value, p1, p2, p3, p4, p5);
        if (tree->value == "->") {
            if (left_num == 1 && right_num == 0) tree->value = "0"; else tree->value = "1";
        } else if (tree->value == "&") {
            if (left_num == 1 && right_num == 1) tree->value = "1"; else tree->value = "0";
        } else {
            if (left_num == 0 && right_num == 0) tree->value = "0"; else tree->value = "1";
        }
    } else if (tree->value == "!") {
        int left_num = get_num(tree->left->value, p1, p2, p3, p4, p5);
        if (left_num == 0) tree->value = "1"; else tree->value = "0";
    } else {
        int num = get_num(tree->value, p1, p2, p3, p4, p5);
        if (num == 0) tree->value = "0"; else tree->value = "1";
    }
}

bool mask_check(int p1, int p2, int p3, int p4, int p5) {
    if_mask_check = true;
    for (int i = 0; i < expressionAssumptions.size(); i++) {
        node *assump_tmp = new node;
        add(expressionAssumptions[i], assump_tmp);
        check_tree(assump_tmp, p1, p2, p3, p4, p5);
        if (assump_tmp->value == "0") return false;
    }
    return true;
}

void check_values() {
    for (int p1 = 0; p1 <= 1; p1++) {
        for (int p2 = 0; p2 <= 1; p2++) {
            for (int p3 = 0; p3 <= 1; p3++) {
                for (int p4 = 0; p4 <= 1; p4++) {
                    for (int p5 = 0; p5 <= 1; p5++) {
                        node *tmp = new node;
                        add(final_line, tmp);
                        if (mask_check(p1, p2, p3, p4, p5)) {
                            if_mask_check = false;
                            check_tree(tmp, p1, p2, p3, p4, p5);
                            if (tmp->value == "0") {
                                cout << "Высказывание ложно при ";
                                cout << invert_variables[0] << "=";
                                if (p1 == 0) cout << "Л"; else cout << "И";
                                if (invert_variables.size() > 1) {
                                    cout << ", ";
                                    cout << invert_variables[1] << "=";
                                    if (p2 == 0) cout << "Л"; else cout << "И";
                                    if (invert_variables.size() > 2) {
                                        cout << ", ";
                                        cout << invert_variables[2] << "=";
                                        if (p3 == 0) cout << "Л"; else cout << "И";
                                        if (invert_variables.size() > 3) {
                                            cout << ", ";
                                            cout << invert_variables[3] << "=";
                                            if (p4 == 0) cout << "Л"; else cout << "И";
                                            if (invert_variables.size() > 4) {
                                                cout << ", ";
                                                cout << invert_variables[4] << "=";
                                                if (p5 == 0) cout << "Л"; else cout << "И";
                                            }
                                        }
                                    }
                                }
                                exit(0);
                            }
                        }
                    }
                }
            }
        }
    }
}


void create_assumptions_tree(string s) {
    node *tmp = new node;
    add(s, tmp);
    assumptions_trees.push_back(tmp);
}

struct numb {
    int a = -1, b = -1, c = -1, d = -1, e = -1;
};

vector<numb> proves_num;
vector<vector<string>> proves;
map<string, bool> var;

node *a;
node *b;
node *c;

vector<string> a_or_nota_ = {
        "(a)->(a)|!(a)",
        "((((a)->((a)|!(a)))->((a)->!((a)|!(a)))->!(a))->!((a)|!(a))->(((a)->((a)|!(a)))->((a)->!((a)|!(a)))->!(a)))->((a)->((a)|!(a)))->((((a)->((a)|!(a)))->((a)->!((a)|!(a)))->!(a))->!((a)|!(a))->(((a)->((a)|!(a)))->((a)->!((a)|!(a)))->!(a)))",
        "((((a)->((a)|!(a)))->((a)->!((a)|!(a)))->!(a))->!((a)|!(a))->(((a)->((a)|!(a)))->((a)->!((a)|!(a)))->!(a)))",
        "((a)->((a)|!(a)))->((((a)->((a)|!(a)))->((a)->!((a)|!(a)))->!(a))->!((a)|!(a))->(((a)->((a)|!(a)))->((a)->!((a)|!(a)))->!(a)))",
        "((((a)->((a)|!(a)))->((a)->!((a)|!(a)))->!(a)))->((a)->((a)|!(a)))->((((a)->((a)|!(a)))->((a)->!((a)|!(a)))->!(a)))",
        "((((a)->((a)|!(a)))->((a)->!((a)|!(a)))->!(a)))",
        "((a)->((a)|!(a)))->((((a)->((a)|!(a)))->((a)->!((a)|!(a)))->!(a)))",
        "(((a)->((a)|!(a)))->(((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a))))->(((a)->((a)|!(a)))->(((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a)))->(!((a)|!(a))->(((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a)))))->(((a)->((a)|!(a)))->(!((a)|!(a))->(((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a)))))",
        "((((a)->((a)|!(a)))->((((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a)))->(!((a)|!(a))->(((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a))))))->(((a)->((a)|!(a)))->(!((a)|!(a))->(((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a))))))",
        "((a)->((a)|!(a)))->(!((a)|!(a))->(((a)->((a)|!(a)))->((a)->!((a)|!(a)))->!(a)))",
        "(((a)->((a)|!(a)))->!((a)|!(a))->((a)->((a)|!(a))))->((a)->((a)|!(a)))->(((a)->((a)|!(a)))->!((a)|!(a))->((a)->((a)|!(a))))",
        "(((a)->((a)|!(a)))->!((a)|!(a))->((a)->((a)|!(a))))",
        "((a)->((a)|!(a)))->(((a)->((a)|!(a)))->!((a)|!(a))->((a)->((a)|!(a))))",
        "((a)->((a)|!(a)))->((a)->((a)|!(a)))->((a)->((a)|!(a)))",
        "(((a)->((a)|!(a)))->((a)->((a)|!(a)))->((a)->((a)|!(a))))->(((a)->((a)|!(a)))->(((a)->((a)|!(a)))->((a)->((a)|!(a))))->((a)->((a)|!(a))))->(((a)->((a)|!(a)))->((a)->((a)|!(a))))",
        "(((a)->((a)|!(a)))->(((a)->((a)|!(a)))->((a)->((a)|!(a))))->((a)->((a)|!(a))))->(((a)->((a)|!(a)))->((a)->((a)|!(a))))",
        "((a)->((a)|!(a)))->(((a)->((a)|!(a)))->((a)->((a)|!(a))))->((a)->((a)|!(a)))",
        "((a)->((a)|!(a)))->((a)->((a)|!(a)))",
        "(((a)->((a)|!(a)))->((a)->((a)|!(a))))->(((a)->((a)|!(a)))->((a)->((a)|!(a)))->(!((a)|!(a))->((a)->((a)|!(a)))))->(((a)->((a)|!(a)))->(!((a)|!(a))->((a)->((a)|!(a)))))",
        "((((a)->((a)|!(a)))->(((a)->((a)|!(a)))->(!((a)|!(a))->((a)->((a)|!(a))))))->(((a)->((a)|!(a)))->(!((a)|!(a))->((a)->((a)|!(a))))))",
        "((a)->((a)|!(a)))->(!((a)|!(a))->((a)->((a)|!(a))))",
        "((!((a)|!(a))->((a)->((a)|!(a))))->(!((a)|!(a))->((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a)))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a))))->((a)->((a)|!(a)))->((!((a)|!(a))->((a)->((a)|!(a))))->(!((a)|!(a))->((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a)))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a))))",
        "((!((a)|!(a))->((a)->((a)|!(a))))->(!((a)|!(a))->((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a)))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a))))",
        "((a)->((a)|!(a)))->((!((a)|!(a))->((a)->((a)|!(a))))->(!((a)|!(a))->((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a)))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a))))",
        "(((a)->((a)|!(a)))->(!((a)|!(a))->((a)->((a)|!(a)))))->(((a)->((a)|!(a)))->(!((a)|!(a))->((a)->((a)|!(a))))->((!((a)|!(a))->(((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a))))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a)))))->(((a)->((a)|!(a)))->((!((a)|!(a))->(((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a))))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a)))))",
        "((((a)->((a)|!(a)))->((!((a)|!(a))->((a)->((a)|!(a))))->((!((a)|!(a))->(((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a))))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a))))))->(((a)->((a)|!(a)))->((!((a)|!(a))->(((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a))))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a))))))",
        "((a)->((a)|!(a)))->(((!((a)|!(a))->(((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a))))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a)))))",
        "(((a)->((a)|!(a)))->(!((a)|!(a))->(((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a)))))->(((a)->((a)|!(a)))->(!((a)|!(a))->(((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a))))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a))))->(((a)->((a)|!(a)))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a))))",
        "((((a)->((a)|!(a)))->((!((a)|!(a))->(((a)->((a)|!(a)))->(((a)->!((a)|!(a)))->!(a))))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a)))))->(((a)->((a)|!(a)))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a)))))",
        "((a)->((a)|!(a)))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a)))",
        "((!((a)|!(a))->(a)->!((a)|!(a)))->!((a)|!(a))->(!((a)|!(a))->(a)->!((a)|!(a))))->((a)->((a)|!(a)))->((!((a)|!(a))->(a)->!((a)|!(a)))->!((a)|!(a))->(!((a)|!(a))->(a)->!((a)|!(a))))",
        "((!((a)|!(a))->(a)->!((a)|!(a)))->!((a)|!(a))->(!((a)|!(a))->(a)->!((a)|!(a))))",
        "((a)->((a)|!(a)))->((!((a)|!(a))->(a)->!((a)|!(a)))->!((a)|!(a))->(!((a)|!(a))->(a)->!((a)|!(a))))",
        "((!((a)|!(a))->(a)->!((a)|!(a))))->((a)->((a)|!(a)))->((!((a)|!(a))->(a)->!((a)|!(a))))",
        "((!((a)|!(a))->(a)->!((a)|!(a))))",
        "((a)->((a)|!(a)))->((!((a)|!(a))->(a)->!((a)|!(a))))",
        "(((a)->((a)|!(a)))->(!((a)|!(a))->((a)->!((a)|!(a)))))->(((a)->((a)|!(a)))->(!((a)|!(a))->((a)->!((a)|!(a))))->(!((a)|!(a))->(!((a)|!(a))->((a)->!((a)|!(a))))))->(((a)->((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->((a)->!((a)|!(a))))))",
        "((((a)->((a)|!(a)))->((!((a)|!(a))->((a)->!((a)|!(a))))->(!((a)|!(a))->(!((a)|!(a))->((a)->!((a)|!(a)))))))->(((a)->((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->((a)->!((a)|!(a)))))))",
        "((a)->((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->(a)->!((a)|!(a))))",
        "(!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))->((a)->((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))",
        "(!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))",
        "((a)->((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))",
        "((!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))))->((a)->((a)|!(a)))->((!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))))",
        "((!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))))",
        "((a)->((a)|!(a)))->((!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))))",
        "(((a)->((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))))->(((a)->((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a))))->((!((a)|!(a))->((!((a)|!(a))->!((a)|!(a)))->!((a)|!(a))))->(!((a)|!(a))->!((a)|!(a)))))->(((a)->((a)|!(a)))->((!((a)|!(a))->((!((a)|!(a))->!((a)|!(a)))->!((a)|!(a))))->(!((a)|!(a))->!((a)|!(a)))))",
        "((((a)->((a)|!(a)))->((!((a)|!(a))->(!((a)|!(a))->!((a)|!(a))))->((!((a)|!(a))->((!((a)|!(a))->!((a)|!(a)))->!((a)|!(a))))->(!((a)|!(a))->!((a)|!(a))))))->(((a)->((a)|!(a)))->((!((a)|!(a))->((!((a)|!(a))->!((a)|!(a)))->!((a)|!(a))))->(!((a)|!(a))->!((a)|!(a))))))",
        "((a)->((a)|!(a)))->((!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))))",
        "(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))->((a)->((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))",
        "(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))",
        "((a)->((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))",
        "(((a)->((a)|!(a)))->(!((a)|!(a))->((!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))))->(((a)->((a)|!(a)))->(!((a)|!(a))->((!((a)|!(a))->!((a)|!(a)))->!((a)|!(a))))->(!((a)|!(a))->!((a)|!(a))))->(((a)->((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))))",
        "((((a)->((a)|!(a)))->((!((a)|!(a))->((!((a)|!(a))->!((a)|!(a)))->!((a)|!(a))))->(!((a)|!(a))->!((a)|!(a)))))->(((a)->((a)|!(a)))->(!((a)|!(a))->!((a)|!(a)))))",
        "((a)->((a)|!(a)))->(!((a)|!(a))->!((a)|!(a)))",
        "((!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))->((a)->!((a)|!(a))))->(!((a)|!(a))->((a)->!((a)|!(a)))))->((a)->((a)|!(a)))->((!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))->((a)->!((a)|!(a))))->(!((a)|!(a))->((a)->!((a)|!(a)))))",
        "((!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))->((a)->!((a)|!(a))))->(!((a)|!(a))->((a)->!((a)|!(a)))))",
        "((a)->((a)|!(a)))->((!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))->((a)->!((a)|!(a))))->(!((a)|!(a))->((a)->!((a)|!(a)))))",
        "(((a)->((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))))->(((a)->((a)|!(a)))->(!((a)|!(a))->!((a)|!(a)))->((!((a)|!(a))->(!((a)|!(a))->((a)->!((a)|!(a)))))->(!((a)|!(a))->((a)->!((a)|!(a))))))->(((a)->((a)|!(a)))->((!((a)|!(a))->(!((a)|!(a))->((a)->!((a)|!(a)))))->(!((a)|!(a))->((a)->!((a)|!(a))))))",
        "((((a)->((a)|!(a)))->((!((a)|!(a))->!((a)|!(a)))->((!((a)|!(a))->(!((a)|!(a))->((a)->!((a)|!(a)))))->(!((a)|!(a))->((a)->!((a)|!(a)))))))->(((a)->((a)|!(a)))->((!((a)|!(a))->(!((a)|!(a))->((a)->!((a)|!(a)))))->(!((a)|!(a))->((a)->!((a)|!(a)))))))",
        "((a)->((a)|!(a)))->(((!((a)|!(a))->(!((a)|!(a))->((a)->!((a)|!(a)))))->(!((a)|!(a))->((a)->!((a)|!(a))))))",
        "(!((a)|!(a))->((a)->!((a)|!(a))))->((a)->((a)|!(a)))->(!((a)|!(a))->((a)->!((a)|!(a))))",
        "(!((a)|!(a))->((a)->!((a)|!(a))))",
        "((a)->((a)|!(a)))->(!((a)|!(a))->((a)->!((a)|!(a))))",
        "((!((a)|!(a))->((a)->!((a)|!(a))))->(!((a)|!(a))->((a)->!((a)|!(a)))->!(a))->(!((a)|!(a))->!(a)))->((a)->((a)|!(a)))->((!((a)|!(a))->((a)->!((a)|!(a))))->(!((a)|!(a))->((a)->!((a)|!(a)))->!(a))->(!((a)|!(a))->!(a)))",
        "((!((a)|!(a))->((a)->!((a)|!(a))))->(!((a)|!(a))->((a)->!((a)|!(a)))->!(a))->(!((a)|!(a))->!(a)))",
        "((a)->((a)|!(a)))->((!((a)|!(a))->((a)->!((a)|!(a))))->(!((a)|!(a))->((a)->!((a)|!(a)))->!(a))->(!((a)|!(a))->!(a)))",
        "(((a)->((a)|!(a)))->(!((a)|!(a))->((a)->!((a)|!(a)))))->(((a)->((a)|!(a)))->(!((a)|!(a))->((a)->!((a)|!(a))))->((!((a)|!(a))->(((a)->!((a)|!(a)))->!(a)))->(!((a)|!(a))->!(a))))->(((a)->((a)|!(a)))->((!((a)|!(a))->(((a)->!((a)|!(a)))->!(a)))->(!((a)|!(a))->!(a))))",
        "((((a)->((a)|!(a)))->((!((a)|!(a))->((a)->!((a)|!(a))))->((!((a)|!(a))->(((a)->!((a)|!(a)))->!(a)))->(!((a)|!(a))->!(a)))))->(((a)->((a)|!(a)))->((!((a)|!(a))->(((a)->!((a)|!(a)))->!(a)))->(!((a)|!(a))->!(a)))))",
        "((a)->((a)|!(a)))->(((!((a)|!(a))->(((a)->!((a)|!(a)))->!(a)))->(!((a)|!(a))->!(a))))",
        "(((a)->((a)|!(a)))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a))))->(((a)->((a)|!(a)))->(!((a)|!(a))->(((a)->!((a)|!(a)))->!(a)))->(!((a)|!(a))->!(a)))->(((a)->((a)|!(a)))->(!((a)|!(a))->!(a)))",
        "((((a)->((a)|!(a)))->((!((a)|!(a))->(((a)->!((a)|!(a)))->!(a)))->(!((a)|!(a))->!(a))))->(((a)->((a)|!(a)))->(!((a)|!(a))->!(a))))",
        "((a)->((a)|!(a)))->(!((a)|!(a))->(!(a)))",
        "!((a)|!(a))->!(a)",
        "!(a)->(a)|!(a)",
        "(((!(a)->((a)|!(a)))->(!(a)->!((a)|!(a)))->!!(a))->!((a)|!(a))->((!(a)->((a)|!(a)))->(!(a)->!((a)|!(a)))->!!(a)))->(!(a)->((a)|!(a)))->(((!(a)->((a)|!(a)))->(!(a)->!((a)|!(a)))->!!(a))->!((a)|!(a))->((!(a)->((a)|!(a)))->(!(a)->!((a)|!(a)))->!!(a)))",
        "(((!(a)->((a)|!(a)))->(!(a)->!((a)|!(a)))->!!(a))->!((a)|!(a))->((!(a)->((a)|!(a)))->(!(a)->!((a)|!(a)))->!!(a)))",
        "(!(a)->((a)|!(a)))->(((!(a)->((a)|!(a)))->(!(a)->!((a)|!(a)))->!!(a))->!((a)|!(a))->((!(a)->((a)|!(a)))->(!(a)->!((a)|!(a)))->!!(a)))",
        "(((!(a)->((a)|!(a)))->(!(a)->!((a)|!(a)))->!!(a)))->(!(a)->((a)|!(a)))->(((!(a)->((a)|!(a)))->(!(a)->!((a)|!(a)))->!!(a)))",
        "(((!(a)->((a)|!(a)))->(!(a)->!((a)|!(a)))->!!(a)))",
        "(!(a)->((a)|!(a)))->(((!(a)->((a)|!(a)))->(!(a)->!((a)|!(a)))->!!(a)))",
        "((!(a)->((a)|!(a)))->((!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a))))->((!(a)->((a)|!(a)))->((!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a)))->(!((a)|!(a))->((!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a)))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->((!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a)))))",
        "(((!(a)->((a)|!(a)))->(((!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a)))->(!((a)|!(a))->((!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a))))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->((!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a))))))",
        "(!(a)->((a)|!(a)))->(!((a)|!(a))->((!(a)->((a)|!(a)))->(!(a)->!((a)|!(a)))->!!(a)))",
        "((!(a)->((a)|!(a)))->!((a)|!(a))->(!(a)->((a)|!(a))))->(!(a)->((a)|!(a)))->((!(a)->((a)|!(a)))->!((a)|!(a))->(!(a)->((a)|!(a))))",
        "((!(a)->((a)|!(a)))->!((a)|!(a))->(!(a)->((a)|!(a))))",
        "(!(a)->((a)|!(a)))->((!(a)->((a)|!(a)))->!((a)|!(a))->(!(a)->((a)|!(a))))",
        "(!(a)->((a)|!(a)))->(!(a)->((a)|!(a)))->(!(a)->((a)|!(a)))",
        "((!(a)->((a)|!(a)))->(!(a)->((a)|!(a)))->(!(a)->((a)|!(a))))->((!(a)->((a)|!(a)))->((!(a)->((a)|!(a)))->(!(a)->((a)|!(a))))->(!(a)->((a)|!(a))))->((!(a)->((a)|!(a)))->(!(a)->((a)|!(a))))",
        "((!(a)->((a)|!(a)))->((!(a)->((a)|!(a)))->(!(a)->((a)|!(a))))->(!(a)->((a)|!(a))))->((!(a)->((a)|!(a)))->(!(a)->((a)|!(a))))",
        "(!(a)->((a)|!(a)))->((!(a)->((a)|!(a)))->(!(a)->((a)|!(a))))->(!(a)->((a)|!(a)))",
        "(!(a)->((a)|!(a)))->(!(a)->((a)|!(a)))",
        "((!(a)->((a)|!(a)))->(!(a)->((a)|!(a))))->((!(a)->((a)|!(a)))->(!(a)->((a)|!(a)))->(!((a)|!(a))->(!(a)->((a)|!(a)))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->(!(a)->((a)|!(a)))))",
        "(((!(a)->((a)|!(a)))->((!(a)->((a)|!(a)))->(!((a)|!(a))->(!(a)->((a)|!(a))))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->(!(a)->((a)|!(a))))))",
        "(!(a)->((a)|!(a)))->(!((a)|!(a))->(!(a)->((a)|!(a))))",
        "((!((a)|!(a))->(!(a)->((a)|!(a))))->(!((a)|!(a))->(!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a)))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a))))->(!(a)->((a)|!(a)))->((!((a)|!(a))->(!(a)->((a)|!(a))))->(!((a)|!(a))->(!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a)))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a))))",
        "((!((a)|!(a))->(!(a)->((a)|!(a))))->(!((a)|!(a))->(!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a)))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a))))",
        "(!(a)->((a)|!(a)))->((!((a)|!(a))->(!(a)->((a)|!(a))))->(!((a)|!(a))->(!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a)))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a))))",
        "((!(a)->((a)|!(a)))->(!((a)|!(a))->(!(a)->((a)|!(a)))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->(!(a)->((a)|!(a))))->((!((a)|!(a))->((!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a))))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a)))))->((!(a)->((a)|!(a)))->((!((a)|!(a))->((!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a))))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a)))))",
        "(((!(a)->((a)|!(a)))->((!((a)|!(a))->(!(a)->((a)|!(a))))->((!((a)|!(a))->((!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a))))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a))))))->((!(a)->((a)|!(a)))->((!((a)|!(a))->((!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a))))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a))))))",
        "(!(a)->((a)|!(a)))->(((!((a)|!(a))->((!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a))))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a)))))",
        "((!(a)->((a)|!(a)))->(!((a)|!(a))->((!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a)))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->((!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a))))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a))))",
        "(((!(a)->((a)|!(a)))->((!((a)|!(a))->((!(a)->((a)|!(a)))->((!(a)->!((a)|!(a)))->!!(a))))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a)))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a)))))",
        "(!(a)->((a)|!(a)))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a)))",
        "((!((a)|!(a))->!(a)->!((a)|!(a)))->!((a)|!(a))->(!((a)|!(a))->!(a)->!((a)|!(a))))->(!(a)->((a)|!(a)))->((!((a)|!(a))->!(a)->!((a)|!(a)))->!((a)|!(a))->(!((a)|!(a))->!(a)->!((a)|!(a))))",
        "((!((a)|!(a))->!(a)->!((a)|!(a)))->!((a)|!(a))->(!((a)|!(a))->!(a)->!((a)|!(a))))",
        "(!(a)->((a)|!(a)))->((!((a)|!(a))->!(a)->!((a)|!(a)))->!((a)|!(a))->(!((a)|!(a))->!(a)->!((a)|!(a))))",
        "((!((a)|!(a))->!(a)->!((a)|!(a))))->(!(a)->((a)|!(a)))->((!((a)|!(a))->!(a)->!((a)|!(a))))",
        "((!((a)|!(a))->!(a)->!((a)|!(a))))",
        "(!(a)->((a)|!(a)))->((!((a)|!(a))->!(a)->!((a)|!(a))))",
        "((!(a)->((a)|!(a)))->(!((a)|!(a))->(!(a)->!((a)|!(a)))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->(!(a)->!((a)|!(a))))->(!((a)|!(a))->(!((a)|!(a))->(!(a)->!((a)|!(a))))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->(!(a)->!((a)|!(a))))))",
        "(((!(a)->((a)|!(a)))->((!((a)|!(a))->(!(a)->!((a)|!(a))))->(!((a)|!(a))->(!((a)|!(a))->(!(a)->!((a)|!(a)))))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->(!(a)->!((a)|!(a)))))))",
        "(!(a)->((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!(a)->!((a)|!(a))))",
        "(!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))->(!(a)->((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))",
        "(!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))",
        "(!(a)->((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))",
        "((!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))))->(!(a)->((a)|!(a)))->((!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))))",
        "((!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))))",
        "(!(a)->((a)|!(a)))->((!((a)|!(a))->!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))))",
        "((!(a)->((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a))))->((!((a)|!(a))->((!((a)|!(a))->!((a)|!(a)))->!((a)|!(a))))->(!((a)|!(a))->!((a)|!(a)))))->((!(a)->((a)|!(a)))->((!((a)|!(a))->((!((a)|!(a))->!((a)|!(a)))->!((a)|!(a))))->(!((a)|!(a))->!((a)|!(a)))))",
        "(((!(a)->((a)|!(a)))->((!((a)|!(a))->(!((a)|!(a))->!((a)|!(a))))->((!((a)|!(a))->((!((a)|!(a))->!((a)|!(a)))->!((a)|!(a))))->(!((a)|!(a))->!((a)|!(a))))))->((!(a)->((a)|!(a)))->((!((a)|!(a))->((!((a)|!(a))->!((a)|!(a)))->!((a)|!(a))))->(!((a)|!(a))->!((a)|!(a))))))",
        "(!(a)->((a)|!(a)))->((!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))))",
        "(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))->(!(a)->((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))",
        "(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))",
        "(!(a)->((a)|!(a)))->(!((a)|!(a))->(!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))",
        "((!(a)->((a)|!(a)))->(!((a)|!(a))->((!((a)|!(a))->!((a)|!(a)))->!((a)|!(a)))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->((!((a)|!(a))->!((a)|!(a)))->!((a)|!(a))))->(!((a)|!(a))->!((a)|!(a))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))))",
        "(((!(a)->((a)|!(a)))->((!((a)|!(a))->((!((a)|!(a))->!((a)|!(a)))->!((a)|!(a))))->(!((a)|!(a))->!((a)|!(a)))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->!((a)|!(a)))))",
        "(!(a)->((a)|!(a)))->(!((a)|!(a))->!((a)|!(a)))",
        "((!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))->(!(a)->!((a)|!(a))))->(!((a)|!(a))->(!(a)->!((a)|!(a)))))->(!(a)->((a)|!(a)))->((!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))->(!(a)->!((a)|!(a))))->(!((a)|!(a))->(!(a)->!((a)|!(a)))))",
        "((!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))->(!(a)->!((a)|!(a))))->(!((a)|!(a))->(!(a)->!((a)|!(a)))))",
        "(!(a)->((a)|!(a)))->((!((a)|!(a))->!((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))->(!(a)->!((a)|!(a))))->(!((a)|!(a))->(!(a)->!((a)|!(a)))))",
        "((!(a)->((a)|!(a)))->(!((a)|!(a))->!((a)|!(a))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->!((a)|!(a)))->((!((a)|!(a))->(!((a)|!(a))->(!(a)->!((a)|!(a)))))->(!((a)|!(a))->(!(a)->!((a)|!(a))))))->((!(a)->((a)|!(a)))->((!((a)|!(a))->(!((a)|!(a))->(!(a)->!((a)|!(a)))))->(!((a)|!(a))->(!(a)->!((a)|!(a))))))",
        "(((!(a)->((a)|!(a)))->((!((a)|!(a))->!((a)|!(a)))->((!((a)|!(a))->(!((a)|!(a))->(!(a)->!((a)|!(a)))))->(!((a)|!(a))->(!(a)->!((a)|!(a)))))))->((!(a)->((a)|!(a)))->((!((a)|!(a))->(!((a)|!(a))->(!(a)->!((a)|!(a)))))->(!((a)|!(a))->(!(a)->!((a)|!(a)))))))",
        "(!(a)->((a)|!(a)))->(((!((a)|!(a))->(!((a)|!(a))->(!(a)->!((a)|!(a)))))->(!((a)|!(a))->(!(a)->!((a)|!(a))))))",
        "(!((a)|!(a))->(!(a)->!((a)|!(a))))->(!(a)->((a)|!(a)))->(!((a)|!(a))->(!(a)->!((a)|!(a))))",
        "(!((a)|!(a))->(!(a)->!((a)|!(a))))",
        "(!(a)->((a)|!(a)))->(!((a)|!(a))->(!(a)->!((a)|!(a))))",
        "((!((a)|!(a))->(!(a)->!((a)|!(a))))->(!((a)|!(a))->(!(a)->!((a)|!(a)))->!!(a))->(!((a)|!(a))->!!(a)))->(!(a)->((a)|!(a)))->((!((a)|!(a))->(!(a)->!((a)|!(a))))->(!((a)|!(a))->(!(a)->!((a)|!(a)))->!!(a))->(!((a)|!(a))->!!(a)))",
        "((!((a)|!(a))->(!(a)->!((a)|!(a))))->(!((a)|!(a))->(!(a)->!((a)|!(a)))->!!(a))->(!((a)|!(a))->!!(a)))",
        "(!(a)->((a)|!(a)))->((!((a)|!(a))->(!(a)->!((a)|!(a))))->(!((a)|!(a))->(!(a)->!((a)|!(a)))->!!(a))->(!((a)|!(a))->!!(a)))",
        "((!(a)->((a)|!(a)))->(!((a)|!(a))->(!(a)->!((a)|!(a)))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->(!(a)->!((a)|!(a))))->((!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a)))->(!((a)|!(a))->!!(a))))->((!(a)->((a)|!(a)))->((!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a)))->(!((a)|!(a))->!!(a))))",
        "(((!(a)->((a)|!(a)))->((!((a)|!(a))->(!(a)->!((a)|!(a))))->((!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a)))->(!((a)|!(a))->!!(a)))))->((!(a)->((a)|!(a)))->((!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a)))->(!((a)|!(a))->!!(a)))))",
        "(!(a)->((a)|!(a)))->(((!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a)))->(!((a)|!(a))->!!(a))))",
        "((!(a)->((a)|!(a)))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a)))->(!((a)|!(a))->!!(a)))->((!(a)->((a)|!(a)))->(!((a)|!(a))->!!(a)))",
        "(((!(a)->((a)|!(a)))->((!((a)|!(a))->((!(a)->!((a)|!(a)))->!!(a)))->(!((a)|!(a))->!!(a))))->((!(a)->((a)|!(a)))->(!((a)|!(a))->!!(a))))",
        "(!(a)->((a)|!(a)))->(!((a)|!(a))->(!!(a)))",
        "!((a)|!(a))->!!(a)",
        "!((a)|!(a))->!(a)",
        "!((a)|!(a))->!!(a)",
        "(!((a)|!(a))->!(a))->(!((a)|!(a))->!!(a))->!!((a)|!(a))",
        "(!((a)|!(a))->!!(a))->!!((a)|!(a))",
        "!!((a)|!(a))",
        "!!((a)|!(a))->((a)|!(a))",
        "(a)|!(a)"
};

vector<string> a_to_nota_ = {
        "(a)",
        "(!(a)->(a))->(!(a)->!(a))->!!(a)",
        "(a)->!(a)->(a)",
        "!(a)->(a)",
        "(!(a)->!(a))->!!(a)",
        "!(a)->!(a)->!(a)",
        "!(a)->(!(a)->!(a))->!(a)",
        "(!(a)->!(a)->!(a))->(!(a)->(!(a)->!(a))->!(a))->(!(a)->!(a))",
        "(!(a)->(!(a)->!(a))->!(a))->(!(a)->!(a))",
        "!(a)->!(a)",
        "!!(a)"
};

vector<string> a_to_b_ = {
        "b",
        "b->(a)->b",
        "(a)->b"
};

vector<string> a_to_notb_ = {
        "(((a)->b)->b)->(((a)->b)->!b)->!((a)->b)",
        "(((a)->b)->(a))->(((a)->b)->((a)->b))->(((a)->b)->b)",
        "(a)",
        "(a)->((a)->b)->(a)",
        "((a)->b)->(a)",
        "(((a)->b)->((a)->b))->(((a)->b)->b)",
        "(((a)->b)->((a)->b)->((a)->b))",
        "(((a)->b)->((a)->b)->((a)->b))->(((a)->b)->(((a)->b)->((a)->b))->((a)->b))->(((a)->b)->((a)->b))",
        "(((a)->b)->(((a)->b)->((a)->b))->((a)->b))->(((a)->b)->((a)->b))",
        "(((a)->b)->(((a)->b)->((a)->b))->((a)->b))",
        "((a)->b)->((a)->b)",
        "((a)->b)->b",
        "!b->((a)->b)->!b",
        "!b->((a)->b)->!b",
        "!b",
        "((a)->b)->!b",
        "(((a)->b)->!b)->!((a)->b)",
        "!((a)->b)"
};

vector<string> nota_to_b_ = {
        "b",
        "b->(a)->b",
        "(a)->b"
};

vector<string> nota_to_notb_ = {
        "((a)->!b->(a))->(a)->((a)->!b->(a))",
        "((a)->!b->(a))",
        "(a)->((a)->!b->(a))",
        "(a)->(a)->(a)",
        "((a)->(a)->(a))->((a)->((a)->(a))->(a))->((a)->(a))",
        "((a)->((a)->(a))->(a))->((a)->(a))",
        "(a)->((a)->(a))->(a)",
        "(a)->(a)",
        "((a)->(a))->((a)->(a)->(!b->(a)))->((a)->(!b->(a)))",
        "((a)->(a)->!b->(a))->((a)->!b->(a))",
        "(a)->!b->(a)",
        "(!(a)->!b->!(a))->(a)->(!(a)->!b->!(a))",
        "!(a)->!b->!(a)",
        "(a)->!(a)->!b->!(a)",
        "!(a)->(a)->!(a)",
        "!(a)",
        "(a)->!(a)",
        "((a)->!(a))->((a)->!(a)->!b->!(a))->((a)->!b->!(a))",
        "((a)->!(a)->!b->!(a))->((a)->!b->!(a))",
        "(a)->!b->!(a)",
        "((!b->(a))->(!b->!(a))->!!b)->(a)->((!b->(a))->(!b->!(a))->!!b)",
        "(!b->(a))->(!b->!(a))->!!b",
        "(a)->((!b->(a))->(!b->!(a))->!!b)",
        "((a)->(!b->(a)))->((a)->(!b->(a))->((!b->!(a))->!!b))->((a)->((!b->!(a))->!!b))",
        "(((a)->((!b->(a))->((!b->!(a))->!!b)))->((a)->((!b->!(a))->!!b)))",
        "(a)->((!b->!(a))->!!b)",
        "((a)->(!b->!(a)))->((a)->(!b->!(a))->!!b)->((a)->!!b)",
        "(((a)->((!b->!(a))->!!b))->((a)->!!b))",
        "(a)->!!b",
        "(!!b->b)->(a)->(!!b->b)",
        "!!b->b",
        "(a)->!!b->b",
        "((a)->!!b)->((a)->!!b->b)->((a)->b)",
        "(((a)->!!b->b)->((a)->b))",
        "(a)->b"
};

vector<string> a_and_b_ = {
        "a",
        "b",
        "(a)->b->(a)&b",
        "b->(a)&b",
        "(a)&b"
};

vector<string> a_and_notb_ = {
        "(a)",
        "!b",
        "((a)&b->b)->((a)&b->!b)->!((a)&b)",
        "(a)&b->b",
        "!b->(a)&b->!b",
        "(a)&b->!b",
        "((a)&b->!b)->!((a)&b)",
        "!((a)&b)"
};

vector<string> nota_and_b_ = {
        "!(a)",
        "b",
        "((a)&b->(a))->((a)&b->!(a))->!((a)&b)",
        "(a)&b->(a)",
        "!(a)->(a)&b->!(a)",
        "(a)&b->!(a)",
        "((a)&b->!(a))->!((a)&b)",
        "!((a)&b)"
};

vector<string> nota_and_notb_ = {
        "!(a)",
        "!b",
        "((a)&b->b)->((a)&b->!b)->!((a)&b)",
        "(a)&b->b",
        "!b->(a)&b->!b",
        "(a)&b->!b",
        "((a)&b->!b)->!((a)&b)",
        "!((a)&b)"
};

vector<string> a_or_b = {
        "(a)",
        "(a)->(a)|(b)",
        "(a)|(b)"
};

vector<string> a_or_notb_ = {
        "(a)->(a)|(b)",
        "a",
        "(a)|(b)"
};

vector<string> nota_or_b_ = {
        "(b)->(a)|(b)",
        "b",
        "(a)|(b)"
};

vector<string> nota_or_notb_ = {
        "!(a)",
        "((a)|b->((a)))->((a)|b->!((a)))->!((a)|b)",
        "((a)->(a))->(b->(a))->((a)|b->(a))",
        "(a)->(a)->(a)",
        "((a)->(a)->(a))->((a)->((a)->(a))->(a))->((a)->(a))",
        "((a)->((a)->(a))->(a))->((a)->(a))",
        "(a)->((a)->(a))->(a)",
        "(a)->(a)",
        "(b->(a))->((a)|b->(a))",
        "(b->!(a)->b)->b->(b->!(a)->b)",
        "(b->!(a)->b)",
        "b->(b->!(a)->b)",
        "b->b->b",
        "(b->b->b)->(b->(b->b)->b)->(b->b)",
        "(b->(b->b)->b)->(b->b)",
        "b->(b->b)->b",
        "b->b",
        "(b->b)->(b->b->(!(a)->b))->(b->(!(a)->b))",
        "(b->b->!(a)->b)->(b->!(a)->b)",
        "b->!(a)->b",
        "(!b->!(a)->!b)->b->(!b->!(a)->!b)",
        "!b->!(a)->!b",
        "b->!b->!(a)->!b",
        "!b->b->!b",
        "!b",
        "b->!b",
        "(b->!b)->(b->!b->!(a)->!b)->(b->!(a)->!b)",
        "(b->!b->!(a)->!b)->(b->!(a)->!b)",
        "b->!(a)->!b",
        "((!(a)->b)->(!(a)->!b)->!!(a))->b->((!(a)->b)->(!(a)->!b)->!!(a))",
        "(!(a)->b)->(!(a)->!b)->!!(a)",
        "b->((!(a)->b)->(!(a)->!b)->!!(a))",
        "(b->(!(a)->b))->(b->(!(a)->b)->((!(a)->!b)->!!(a)))->(b->((!(a)->!b)->!!(a)))",
        "((b->((!(a)->b)->((!(a)->!b)->!!(a))))->(b->((!(a)->!b)->!!(a))))",
        "b->((!(a)->!b)->!!(a))",
        "(b->(!(a)->!b))->(b->(!(a)->!b)->!!(a))->(b->!!(a))",
        "((b->((!(a)->!b)->!!(a)))->(b->!!(a)))",
        "b->!!(a)",
        "(!!(a)->(a))->b->(!!(a)->(a))",
        "!!(a)->(a)",
        "b->!!(a)->(a)",
        "(b->!!(a))->(b->!!(a)->(a))->(b->(a))",
        "((b->!!(a)->(a))->(b->(a)))",
        "b->(a)",
        "(a)|b->(a)",
        "((a)|b->!(a))->!((a)|b)",
        "!(a)->(a)|b->!(a)",
        "(a)|b->!(a)",
        "!((a)|b)"
};

void replace_two(string a, string b, int step) {
    string ans;
    for (int i = 0; i < proves[step].size(); i++) {
        ans = "";
        for (int q = 0; q < proves[step][i].length(); q++) {
            if (proves[step][i][q] == 'a') {
                ans += a;
            } else if (proves[step][i][q] == 'b') {
                ans += b;
            } else {
                ans += proves[step][i][q];
            }
        }
        proves[step][i] = ans;
    }
}

void prove_tree(node *tree, int step) {
    if (tree->left != nullptr) prove_tree(tree->left, step);
    if (tree->right != nullptr) prove_tree(tree->right, step);
    if (tree->value == "->" || tree->value == "&" || tree->value == "|") {
        bool fa = false, fb = false;
        a = new node;
        a->value = tree->left->value;
        a->left = tree->left->left;
        a->right = tree->left->right;
        b = new node;
        b->value = tree->right->value;
        b->left = tree->right->left;
        b->right = tree->right->right;
        if (var.count(expressionParser(a->value))) {
            fa = true;
        }
        if (var.count(expressionParser(b->value))) {
            fb = true;
        }
        if (fa && fb) {
            if (tree->value == "->") {
                proves[step].insert(proves[step].end(), a_to_b_.begin(), a_to_b_.end());
                tree->value = "(" + a->value + "->" + b->value + ")";
                var[expressionParser(tree->value)] = true;
            } else if (tree->value == "&") {
                proves[step].insert(proves[step].end(), a_and_b_.begin(), a_and_b_.end());
                tree->value = "(" + a->value + "&" + b->value + ")";
                var[expressionParser(tree->value)] = true;
            } else if (tree->value == "|") {
                proves[step].insert(proves[step].end(), a_or_b.begin(), a_or_b.end());
                tree->value = "(" + a->value + "|" + b->value + ")";
                var[expressionParser(tree->value)] = true;
            }
            replace_two("(" + a->value + ")", "(" + b->value + ")", step);
        } else if (fa && !fb) {
            if (tree->value == "->") {
                proves[step].insert(proves[step].end(), a_to_notb_.begin(), a_to_notb_.end());
                tree->value = "(" + a->value + "->" + b->value + ")";
                var[expressionParser("!(" + tree->value + ")")] = true;
            } else if (tree->value == "&") {
                proves[step].insert(proves[step].end(), a_and_notb_.begin(), a_and_notb_.end());
                tree->value = "(" + a->value + "&" + b->value + ")";
                var[expressionParser("!(" + tree->value + ")")] = true;
            } else if (tree->value == "|") {
                proves[step].insert(proves[step].end(), a_or_notb_.begin(), a_or_notb_.end());
                tree->value = "(" + a->value + "|" + b->value + ")";
                var[expressionParser(tree->value)] = true;
            }
            replace_two("(" + a->value + ")", "(" + b->value + ")", step);
        } else if (!fa && fb) {
            if (tree->value == "->") {
                proves[step].insert(proves[step].end(), nota_to_b_.begin(), nota_to_b_.end());
                tree->value = "(" + a->value + "->" + b->value + ")";
                var[expressionParser(tree->value)] = true;
            } else if (tree->value == "&") {
                proves[step].insert(proves[step].end(), nota_and_b_.begin(), nota_and_b_.end());
                tree->value = "(" + a->value + "&" + b->value + ")";
                var[expressionParser("!(" + tree->value + ")")] = true;
            } else if (tree->value == "|") {
                proves[step].insert(proves[step].end(), nota_or_b_.begin(), nota_or_b_.end());
                tree->value = "(" + a->value + "|" + b->value + ")";
                var[expressionParser(tree->value)] = true;
            }
            replace_two("(" + a->value + ")", "(" + b->value + ")", step);
        } else {
            if (tree->value == "->") {
                proves[step].insert(proves[step].end(), nota_to_notb_.begin(), nota_to_notb_.end());
                tree->value = "(" + a->value + "->" + b->value + ")";
                var[expressionParser(tree->value)] = true;
            } else if (tree->value == "&") {
                proves[step].insert(proves[step].end(), nota_and_notb_.begin(), nota_and_notb_.end());
                tree->value = "(" + a->value + "&" + b->value + ")";
                var[expressionParser("!(" + tree->value + ")")] = true;
            } else if (tree->value == "|") {
                proves[step].insert(proves[step].end(), nota_or_notb_.begin(), nota_or_notb_.end());
                tree->value = "(" + a->value + "|" + b->value + ")";
                var[expressionParser("!(" + tree->value + ")")] = true;
            }
            replace_two("(" + a->value + ")", "(" + b->value + ")", step);
        }
        free(a);
        free(b);
    } else if (tree->value == "!") {
        if (tree->left->value == "!") {
            a = new node;
            a->value = tree->left->left->value;
            a->left = tree->left->left->left;
            a->right = tree->left->left->right;
            if (var.count(expressionParser(a->value))) {
                if (var[a->value]) {
                    var[expressionParser("!(!(" + a->value + "))")] = true;
                    proves[step].insert(proves[step].end(), a_to_nota_.begin(), a_to_nota_.end());
                    tree->value = "!(!(" + a->value + "))";
                    replace_two(a->value, "", step);
                }
            } else {
                if (!var.count(expressionParser("!(" + a->value + ")"))) {
                    var[expressionParser("!(" + a->value + ")")] = true;
                }
                proves[step].insert(proves[step].end(), a_to_nota_.begin(), a_to_nota_.end());
                tree->value = "!(!(" + a->value + "))";
                replace_two("!" + a->value, "", step);
            }
        } else {
            a = new node;
            a->value = tree->left->value;
            a->left = tree->left->left;
            a->right = tree->left->right;
            if (var.count(expressionParser("!(" + a->value + ")"))) {
                tree->value = "!(" + a->value + ")";
            } else {
                var[expressionParser(a->value)] = true;
                var[expressionParser("!(!(" + a->value + "))")] = true;
                proves[step].insert(proves[step].end(), a_to_nota_.begin(), a_to_nota_.end());
                tree->value = "!(" + a->value + ")";
                replace_two(a->value, "", step);
            }
        }
    }
}

void prove_steps(string s, int step) {
    final_tree = new node;
    add(s, final_tree);
    prove_tree(final_tree, step);
}

void prove(string s, int count) {
    switch (count) {
        case 1: {
            proves.resize(2);
            int cnt = 0;
            for (int p1 = 1; p1 >= 0; p1--) {
                if (p1 == 1) {
                    string tmp = "";
                    tmp += invert_variables[0];
                    var[tmp] = true;
                } else {
                    string tmp = "!";
                    tmp += invert_variables[0];
                    var[expressionParser(tmp)] = true;
                }
                numb tmp;
                tmp.a = p1;
                proves_num.push_back(tmp);
                prove_steps(s, cnt);
                cnt++;
                var.clear();
            }
            break;
        }
        case 2: {
            proves.resize(4);
            int cnt = 0;
            for (int p1 = 1; p1 >= 0; p1--) {
                for (int p2 = 1; p2 >= 0; p2--) {
                    if (p1 == 1) {
                        string tmp = "";
                        tmp += invert_variables[0];
                        var[tmp] = true;
                    } else {
                        string tmp = "!";
                        tmp += invert_variables[0];
                        var[expressionParser(tmp)] = true;
                    }
                    if (p2 == 1) {
                        string tmp = "";
                        tmp += invert_variables[1];
                        var[tmp] = true;
                    } else {
                        string tmp = "!";
                        tmp += invert_variables[1];
                        var[expressionParser(tmp)] = true;
                    }
                    numb tmp;
                    tmp.a = p1;
                    tmp.b = p2;
                    proves_num.push_back(tmp);
                    prove_steps(s, cnt);
                    cnt++;
                    var.clear();
                }
            }
            break;
        }
        case 3: {
            proves.resize(8);
            int cnt = 0;
            for (int p1 = 1; p1 >= 0; p1--) {
                for (int p2 = 1; p2 >= 0; p2--) {
                    for (int p3 = 1; p3 >= 0; p3--) {
                        if (p1 == 1) {
                            string tmp = "";
                            tmp += invert_variables[0];
                            var[tmp] = true;
                        } else {
                            string tmp = "!";
                            tmp += invert_variables[0];
                            var[expressionParser(tmp)] = true;
                        }
                        if (p2 == 1) {
                            string tmp = "";
                            tmp += invert_variables[1];
                            var[tmp] = true;
                        } else {
                            string tmp = "!";
                            tmp += invert_variables[1];
                            var[expressionParser(tmp)] = true;
                        }
                        if (p3 == 1) {
                            string tmp = "";
                            tmp += invert_variables[2];
                            var[tmp] = true;
                        } else {
                            string tmp = "!";
                            tmp += invert_variables[2];
                            var[expressionParser(tmp)] = true;
                        }
                        numb tmp;
                        tmp.a = p1;
                        tmp.b = p2;
                        tmp.c = p3;
                        proves_num.push_back(tmp);
                        prove_steps(s, cnt);
                        cnt++;
                        var.clear();
                    }
                }
            }
            break;
        }
        case 4: {
            proves.resize(16);
            int cnt = 0;
            for (int p1 = 1; p1 >= 0; p1--) {
                for (int p2 = 1; p2 >= 0; p2--) {
                    for (int p3 = 1; p3 >= 0; p3--) {
                        for (int p4 = 1; p4 >= 0; p4--) {
                            if (p1 == 1) {
                                string tmp = "";
                                tmp += invert_variables[0];
                                var[tmp] = true;
                            } else {
                                string tmp = "!";
                                tmp += invert_variables[0];
                                var[expressionParser(tmp)] = true;
                            }
                            if (p2 == 1) {
                                string tmp = "";
                                tmp += invert_variables[1];
                                var[tmp] = true;
                            } else {
                                string tmp = "!";
                                tmp += invert_variables[1];
                                var[expressionParser(tmp)] = true;
                            }
                            if (p3 == 1) {
                                string tmp = "";
                                tmp += invert_variables[2];
                                var[tmp] = true;
                            } else {
                                string tmp = "!";
                                tmp += invert_variables[2];
                                var[expressionParser(tmp)] = true;
                            }
                            if (p4 == 1) {
                                string tmp = "";
                                tmp += invert_variables[3];
                                var[tmp] = true;
                            } else {
                                string tmp = "!";
                                tmp += invert_variables[3];
                                var[expressionParser(tmp)] = true;
                            }
                            numb tmp;
                            tmp.a = p1;
                            tmp.b = p2;
                            tmp.c = p3;
                            tmp.d = p4;
                            proves_num.push_back(tmp);
                            prove_steps(s, cnt);
                            cnt++;
                            var.clear();
                        }
                    }
                }
            }
            break;
        }
        case 5: {
            proves.resize(32);
            int cnt = 0;
            for (int p1 = 1; p1 >= 0; p1--) {
                for (int p2 = 1; p2 >= 0; p2--) {
                    for (int p3 = 1; p3 >= 0; p3--) {
                        for (int p4 = 1; p4 >= 0; p4--) {
                            for (int p5 = 1; p5 >= 0; p5--) {
                                if (p1 == 1) {
                                    string tmp = "";
                                    tmp += invert_variables[0];
                                    var[tmp] = true;
                                } else {
                                    string tmp = "!";
                                    tmp += invert_variables[0];
                                    var[expressionParser(tmp)] = true;
                                }
                                if (p2 == 1) {
                                    string tmp = "";
                                    tmp += invert_variables[1];
                                    var[tmp] = true;
                                } else {
                                    string tmp = "!";
                                    tmp += invert_variables[1];
                                    var[expressionParser(tmp)] = true;
                                }
                                if (p3 == 1) {
                                    string tmp = "";
                                    tmp += invert_variables[2];
                                    var[tmp] = true;
                                } else {
                                    string tmp = "!";
                                    tmp += invert_variables[2];
                                    var[expressionParser(tmp)] = true;
                                }
                                if (p4 == 1) {
                                    string tmp = "";
                                    tmp += invert_variables[3];
                                    var[tmp] = true;
                                } else {
                                    string tmp = "!";
                                    tmp += invert_variables[3];
                                    var[expressionParser(tmp)] = true;
                                }
                                if (p5 == 1) {
                                    string tmp = "";
                                    tmp += invert_variables[4];
                                    var[tmp] = true;
                                } else {
                                    string tmp = "!";
                                    tmp += invert_variables[4];
                                    var[expressionParser(tmp)] = true;
                                }
                                numb tmp;
                                tmp.a = p1;
                                tmp.b = p2;
                                tmp.c = p3;
                                tmp.d = p4;
                                tmp.e = p5;
                                proves_num.push_back(tmp);
                                prove_steps(s, cnt);
                                cnt++;
                                var.clear();
                            }
                        }
                    }
                }
            }
            break;
        }
    }
}

vector<string> expressionlines;

void create_expression_tree(vector<string> lines) {
    for (int i = 0; i < lines.size(); i++) {
        node *line = new node;
        expressionlines.push_back(expressionParser(lines[i]));
        add(expressionlines[i], line);
        lines_trees.push_back(line);
    }
}

struct parse {
    bool fx = false;
    int num = 0;
};

vector<parse> parser;

bool axiom_search(node *tree, node *axiom_tree) {
    if (axiom_tree == nullptr && tree == nullptr) return true;
    if ((axiom_tree == nullptr && tree != nullptr) || (axiom_tree != nullptr && tree == nullptr)) return false;
    if (axiom_tree->value == "A") {
        if (a == nullptr) {
            a = new node;
            a->value = tree->value;
            a->left = tree->left;
            a->right = tree->right;
            return true;
        } else {
            return compare_trees(a, tree);
        }
    } else if (axiom_tree->value == "B") {
        if (b == nullptr) {
            b = new node;
            b->value = tree->value;
            b->left = tree->left;
            b->right = tree->right;
            return true;
        } else {
            return compare_trees(b, tree);
        }
    } else if (axiom_tree->value == "C") {
        if (c == nullptr) {
            c = new node;
            c->value = tree->value;
            c->left = tree->left;
            c->right = tree->right;
            return true;
        } else {
            return compare_trees(c, tree);
        }
    } else if ((axiom_tree->value == "&" || axiom_tree->value == "|" || axiom_tree->value == "->") &&
               (axiom_tree->value == tree->value)) {
        return axiom_search(tree->left, axiom_tree->left) & axiom_search(tree->right, axiom_tree->right);
    } else if (axiom_tree->value == tree->value) {
        return axiom_search(tree->left, axiom_tree->left);
    } else return false;
}

int axioms_check(int cur) {
    node *tmp = lines_trees[cur];
    for (int i = 0; i < 10; i++) {
        node *axiom_tmp = axioms_trees[i];
        a = nullptr;
        b = nullptr;
        c = nullptr;
        if (axiom_search(tmp, axiom_tmp)) {
            free(a);
            free(b);
            free(c);
            return i + 1;
        }
        free(a);
        free(b);
        free(c);
    }
    return -1;
}

map<string, vector<int>> right_part;
map<string, int> all_part;
map<int, string> left_part;

void mp_add(string s, int ind) {
    if (s[0] == '(') {
        s.erase(0, 1);
        s.erase(s.length() - 1, 1);
    }
    if (s[0] == '-') {
        int start = 3;
        int brackets_count = 0;
        string left_s = "", right_s = "";
        bool part = false;
        for (int i = start; i < s.length(); i++) {
            if (s[i] == '(') brackets_count++;
            else if (s[i] == ')') brackets_count--;
            if (brackets_count == 0 && s[i] == ',') part = true;
            else if (!part) left_s += s[i]; else right_s += s[i];
        }
        right_part[right_s].push_back(ind);
        left_part[ind] = left_s;
    }
}

map<string, int> deduct_assumptions;

void get_annotation(int cur) {
    string ss = expressionlines[cur];
    if (deduct_assumptions.count(ss) > 0) {
        parse tmp;
        tmp.fx = true;
        tmp.num = 0;
        parser.push_back(tmp);
        all_part[ss] = cur;
        mp_add(ss, cur);
        return;
    }
    int axioms_ans = axioms_check(cur);
    if (axioms_ans != -1) {
        parse tmp;
        tmp.fx = true;
        tmp.num = 0;
        parser.push_back(tmp);
        all_part[ss] = cur;
        mp_add(ss, cur);
        return;
    }
    if (right_part.count(ss) > 0) {
        for (int i = 0; i < right_part[ss].size(); i++) {
            int first = right_part[ss][i];
            if (left_part.count(first) > 0) {
                string left_s = left_part[first];
                if (all_part.count(left_s) > 0) {
                    parse tmp;
                    tmp.fx = false;
                    tmp.num = all_part[left_s];
                    parser.push_back(tmp);
                    all_part[ss] = cur;
                    mp_add(ss, cur);
                    return;
                }
            }
        }
    }
    parse tmp;
    tmp.fx = false;
    tmp.num = 0;
    parser.push_back(tmp);
    all_part[ss] = cur;
    mp_add(ss, cur);
}

vector<string> use_deduct(vector<string> lines, string last_s) {
    create_expression_tree(lines);
    vector<string> ans;
    for (int i = 0; i < lines.size(); i++) {
        get_annotation(i);
        string q = lines[i];
        if (parser[i].fx) {
            ans.push_back("(" + q + ")");
            ans.push_back("((" + q + ")->((" + last_s + ")->(" + q + ")))");
            ans.push_back("((" + last_s + ")->(" + q + "))");
        } else if (expressionParser(q) == expressionParser(last_s)) {
            ans.push_back("((" + q + ")->((" + q + ")->(" + q + ")))");
            ans.push_back("((" + q + ")->(((" + q + ")->(" + q + "))->(" + q + ")))");
            ans.push_back("(((" + q + ")->((" + q + ")->(" + q + ")))->(((" + q + ")->(((" + q + ")->(" + q
                          + "))->(" + q + ")))->((" + q + ")->(" + q + "))))");
            ans.push_back("(((" + q + ")->(((" + q + ")->(" + q + "))->(" + q + ")))->((" + q + ")->(" + q
                          + ")))");
            ans.push_back("((" + q + ")->(" + q + "))");
        } else {
            string w = lines[parser[i].num];
            ans.push_back("(((" + last_s + ")->(" + w + "))->(((" + last_s + ")->((" + w + ")->(" + q + ")))->(("
                          + last_s + ")->(" + q + "))))");
            ans.push_back("(((" + last_s + ")->((" + w + ")->(" + q + ")))->((" + last_s + ")->(" + q + ")))");
            ans.push_back("((" + last_s + ")->(" + q + "))");
        };
    }
    expressionlines.clear();
    lines_trees.clear();
    right_part.clear();
    all_part.clear();
    left_part.clear();
    parser.clear();
    deduct_assumptions.clear();
    return ans;
}

void get_deduce_assump(numb tmp, string line) {
    string s;
    if (tmp.a == 1) {
        s = "";
        s += invert_variables[0];
        if (s != line) deduct_assumptions[s] = 1;
    } else {
        s = "!";
        s += invert_variables[0];
        if (s != line)deduct_assumptions[expressionParser(s)] = 1;
    }
    if (tmp.b != -1) {
        if (tmp.b == 1) {
            s = "";
            s += invert_variables[1];
            if (s != line)deduct_assumptions[s] = 1;
        } else {
            s = "!";
            s += invert_variables[1];
            if (s != line)deduct_assumptions[expressionParser(s)] = 1;
        }
        if (tmp.c != -1) {
            if (tmp.c == 1) {
                s = "";
                s += invert_variables[2];
                if (s != line)deduct_assumptions[s] = 1;
            } else {
                s = "!";
                s += invert_variables[2];
                if (s != line)deduct_assumptions[expressionParser(s)] = 1;
            }
            if (tmp.d != -1) {
                if (tmp.d == 1) {
                    s = "";
                    s += invert_variables[3];
                    if (s != line)deduct_assumptions[s] = 1;
                } else {
                    s = "!";
                    s += invert_variables[3];
                    if (s != line)deduct_assumptions[expressionParser(s)] = 1;
                }
                if (tmp.e != -1) {
                    if (tmp.e == 1) {
                        s = "";
                        s += invert_variables[4];
                        if (s != line)deduct_assumptions[s] = 1;
                    } else {
                        s = "!";
                        s += invert_variables[4];
                        if (s != line) deduct_assumptions[expressionParser(s)] = 1;
                    }
                }
            }
        }
    }
}

int where_check = -1;
bool ifcheck = false;

bool bit_check(numb val1, numb val2, int count) {
    switch (count) {
        case 1: {
            if (val1.a != val2.a) {
                if (!ifcheck) {
                    ifcheck = true;
                    where_check = 1;
                }
                return true;
            } else return false;
            break;
        }
        case 2: {
            if (val1.b != val2.b && !bit_check(val1, val2, 1)) {
                if (!ifcheck) {
                    ifcheck = true;
                    where_check = 2;
                }
                return true;
            } else return false;
            break;
        }
        case 3: {
            if (val1.c != val2.c && !bit_check(val1, val2, 2)) {
                if (!ifcheck) {
                    ifcheck = true;
                    where_check = 3;
                }
                return true;
            } else return false;
            break;
        }
        case 4: {
            if (val1.d != val2.d && !bit_check(val1, val2, 3)) {
                if (!ifcheck) {
                    ifcheck = true;
                    where_check = 4;
                }
                return true;
            } else return false;
            break;
        }
        case 5: {
            if (val1.e != val2.e && !bit_check(val1, val2, 4)) {
                if (!ifcheck) {
                    ifcheck = true;
                    where_check = 5;
                }
                return true;
            } else return false;
            break;
        }
    }
}

string get_one_assump(numb val, int count) {
    switch (count) {
        case 1: {
            string tmp;
            tmp += invert_variables[0];
            if (val.a == 1) return tmp; else return "!" + tmp;
        }
        case 2: {
            string tmp;
            tmp += invert_variables[1];
            if (val.b == 1) return tmp; else return "!" + tmp;
        }
        case 3: {
            string tmp;
            tmp += invert_variables[2];
            if (val.c == 1) return tmp; else return "!" + tmp;
        }
        case 4: {
            string tmp;
            tmp += invert_variables[3];
            if (val.d == 1) return tmp; else return "!" + tmp;
        }
        case 5: {
            string tmp;
            tmp += invert_variables[4];
            if (val.e == 1) return tmp; else return "!" + tmp;
        }
    }
}

vector<string> tmpa;

void replace_tmpa(string a) {
    string ans;
    for (int i = 0; i < tmpa.size(); i++) {
        ans = "";
        for (int q = 0; q < tmpa[i].length(); q++) {
            if (tmpa[i][q] == 'a') {
                ans += a;
            } else {
                ans += tmpa[i][q];
            }
        }
        tmpa[i] = ans;
    }
}

string pline;

numb full_proves_num(numb val1) {
    numb tmp;
    if (val1.e == -1) tmp.e = -1;
    else {
        if (where_check == 5) tmp.e = -1; else tmp.e = val1.e;
    }
    if (val1.d == -1) tmp.d = -1;
    else {
        if (where_check == 4) tmp.d = -1; else tmp.d = val1.d;
    }
    if (val1.c == -1) tmp.c = -1;
    else {
        if (where_check == 3) tmp.c = -1; else tmp.c = val1.c;
    }
    if (val1.b == -1) tmp.b = -1;
    else {
        if (where_check == 2) tmp.b = -1; else tmp.b = val1.b;
    }
    if (where_check == 1) tmp.a = -1; else tmp.a = val1.a;
    return tmp;
}

void prove2(int count) {
    int proves_count;
    switch (count) {
        case 1: {
            proves_count = 2;
            break;
        }
        case 2: {
            proves_count = 4;
            break;
        }
        case 3: {
            proves_count = 8;
            break;
        }
        case 4: {
            proves_count = 16;
            break;
        }
        case 5: {
            proves_count = 32;
            break;
        }
    }
    int i = 0, j = 1;
    while (proves_count > 1) {
        ifcheck = false;
        if (i != j && proves[i].size() > 0 && proves[j].size() > 0 && bit_check(proves_num[i], proves_num[j], count)) {
            string tmp1 = get_one_assump(proves_num[i], where_check);
            string tmp2 = tmp1;
            get_deduce_assump(proves_num[i], tmp1);
            vector<string> deduct1 = use_deduct(proves[i], tmp1);
            if (tmp1[0] == '!') {
                tmp1.erase(0, 1);
                tmp2 = tmp1;
            } else {
                tmp1 = "!" + tmp1;
            }
            get_deduce_assump(proves_num[j], tmp1);
            vector<string> deduct2 = use_deduct(proves[j], tmp1);
            deduct1.insert(deduct1.end(), deduct2.begin(), deduct2.end());
            tmpa = a_or_nota_;
            replace_tmpa(tmp2);
            deduct1.insert(deduct1.end(), tmpa.begin(), tmpa.end());
            tmpa.clear();
            deduct1.push_back(
                    "(" + tmp2 + "->" + pline + ")->(!" + tmp2 + "->" + pline + ")->(" + tmp2 + "|!" + tmp2 + "->" +
                    pline + ")");
            deduct1.push_back("(!" + tmp2 + "->" + pline + ")->(" + tmp2 + "|!" + tmp2 + "->" + pline + ")");
            deduct1.push_back("(" + tmp2 + "|!" + tmp2 + "->" + pline + ")");
            deduct1.push_back(pline);
            proves[i].clear();
            proves[j].clear();
            proves.push_back(deduct1);
            proves_num.push_back(full_proves_num(proves_num[i]));
            proves_count--;
            if (proves_count == 16 || proves_count == 8 || proves_count == 4 || proves_count == 2) count--;
        }
        i += 2;
        j += 2;
    }
}

int main() {
    std::ios::sync_with_stdio(false);
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
    string start_s, ans_s;
    vector<string> assmp;
    create_axioms_tree();
    getline(cin, start_s);
    ans_s = start_s;
    find_variable(start_s);
    long long j = 0;
    while (true) {
        if (start_s[j] == ',') {
            string assumption = start_s.substr(0, j);
            start_s.erase(0, j + 1);
            if (assumption.length() > 0) {
                expressionAssumptions.push_back(expressionParser(assumption));
                assumptions[expressionAssumptions[expressionAssumptions.size() - 1]] = assumptions.size();
                assmp.push_back(assumption);
                create_assumptions_tree(expressionAssumptions[expressionAssumptions.size() - 1]);
            }
            j = -1;
        } else if (start_s[j] == '|' && start_s[j + 1] == '=') {
            string assumption = start_s.substr(0, j);
            start_s.erase(0, j + 2);
            if (assumption.length() > 0) {
                expressionAssumptions.push_back(expressionParser(assumption));
                assumptions[expressionAssumptions[expressionAssumptions.size() - 1]] = assumptions.size();
                assmp.push_back(assumption);
                create_assumptions_tree(expressionAssumptions[expressionAssumptions.size() - 1]);
            }
            final_line = expressionParser(start_s);
            break;
        }
        j++;
    }
    check_values();
    final_line = "";
    for (int i = 0; i < assmp.size(); i++) {
        final_line += "(" + assmp[i] + ")->";
    }
    final_line += start_s;
    pline = final_line;
    final_line = expressionParser(final_line);
    replace(ans_s.begin(), ans_s.end(), '=', '-');
    cout << ans_s << endl;
    prove(final_line, variables.size());
    prove2(variables.size());
    for (int i = 0; i < proves[proves.size() - 1].size(); i++) {
        cout << proves[proves.size() - 1][i] << endl;
    }
    for (int i = 0; i < assmp.size(); i++) {
        cout << assmp[i] << endl;
    }
    for (int i = 0; i < assmp.size(); i++) {
        pline.erase(0, assmp[i].length() + 4);
        cout << pline << endl;
    }
    return 0;
}